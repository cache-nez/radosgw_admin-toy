//
// Created by cache-nez on 20.10.17.
//

#include <iostream>
#include "common.h"

using std::cout;

void unrecognized_command_message(const std::string& command) {
    cout << "Unrecognized command: " << command << std::endl;
}

void help_message() {
    cout << "usage: radosgw-admin <cmd> [options...]" << std::endl;
    cout << "commands:\n";
    cout << "  user create                create a new user\n" ;
    cout << "  user modify                modify user\n";
    cout << "  user info                  get user info\n";
    cout << "  user rm                    remove user\n";
    cout << "  user suspend               suspend a user\n";
    cout << "  user enable                re-enable user after suspension\n";
    cout << "  user check                 check user info\n";
    cout << "  user stats                 show user stats as accounted by quota subsystem\n";
    cout << "  user list                  list users\n";
    cout << "  caps add                   add user capabilities\n";
    cout << "  caps rm                    remove user capabilities\n";
    cout << "  subuser create             create a new subuser\n" ;
    cout << "  subuser modify             modify subuser\n";
    cout << "  subuser rm                 remove subuser\n";
    cout << "  key create                 create access key\n";
    cout << "  key rm                     remove access key\n";
    cout << "  bucket list                list buckets\n";
    cout << "  bucket limit check         show bucket sharding stats\n";
    cout << "  bucket link                link bucket to specified user\n";
    cout << "  bucket unlink              unlink bucket from specified user\n";
    cout << "  bucket stats               returns bucket statistics\n";
    cout << "  bucket rm                  remove bucket\n";
    cout << "  bucket check               check bucket index\n";
    cout << "  bucket reshard             reshard bucket\n";
    cout << "  bucket sync disable        disable bucket sync\n";
    cout << "  bucket sync enable         enable bucket sync\n";
    cout << "  bi get                     retrieve bucket index object entries\n";
    cout << "  bi put                     store bucket index object entries\n";
    cout << "  bi list                    list raw bucket index entries\n";
    cout << "  object rm                  remove object\n";
    cout << "  object stat                stat an object for its metadata\n";
    cout << "  object unlink              unlink object from bucket index\n";
    cout << "  objects expire             run expired objects cleanup\n";
    cout << "  period delete              delete a period\n";
    cout << "  period get                 get period info\n";
    cout << "  period get-current         get current period info\n";
    cout << "  period pull                pull a period\n";
    cout << "  period push                push a period\n";
    cout << "  period list                list all periods\n";
    cout << "  period update              update the staging period\n";
    cout << "  period commit              commit the staging period\n";
    cout << "  quota set                  set quota params\n";
    cout << "  quota enable               enable quota\n";
    cout << "  quota disable              disable quota\n";
    cout << "  global quota get           view global quota params\n";
    cout << "  global quota set           set global quota params\n";
    cout << "  global quota enable        enable a global quota\n";
    cout << "  global quota disable       disable a global quota\n";
    cout << "  realm create               create a new realm\n";
    cout << "  realm delete               delete a realm\n";
    cout << "  realm get                  show realm info\n";
    cout << "  realm get-default          get default realm name\n";
    cout << "  realm list                 list realms\n";
    cout << "  realm list-periods         list all realm periods\n";
    cout << "  realm remove               remove a zonegroup from the realm\n";
    cout << "  realm rename               rename a realm\n";
    cout << "  realm set                  set realm info (requires infile)\n";
    cout << "  realm default              set realm as default\n";
    cout << "  realm pull                 pull a realm and its current period\n";
    cout << "  zonegroup add              add a zone to a zonegroup\n";
    cout << "  zonegroup create           create a new zone group info\n";
    cout << "  zonegroup default          set default zone group\n";
    cout << "  zonegroup delete           delete a zone group info\n";
    cout << "  zonegroup get              show zone group info\n";
    cout << "  zonegroup modify           modify an existing zonegroup\n";
    cout << "  zonegroup set              set zone group info (requires infile)\n";
    cout << "  zonegroup remove           remove a zone from a zonegroup\n";
    cout << "  zonegroup rename           rename a zone group\n";
    cout << "  zonegroup list             list all zone groups set on this cluster\n";
    cout << "  zonegroup placement list   list zonegroup's placement targets\n";
    cout << "  zonegroup placement add    add a placement target id to a zonegroup\n";
    cout << "  zonegroup placement modify modify a placement target of a specific zonegroup\n";
    cout << "  zonegroup placement rm     remove a placement target from a zonegroup\n";
    cout << "  zonegroup placement default  set a zonegroup's default placement target\n";
    cout << "  zone create                create a new zone\n";
    cout << "  zone delete                delete a zone\n";
    cout << "  zone get                   show zone cluster params\n";
    cout << "  zone modify                modify an existing zone\n";
    cout << "  zone set                   set zone cluster params (requires infile)\n";
    cout << "  zone list                  list all zones set on this cluster\n";
    cout << "  zone rename                rename a zone\n";
    cout << "  zone placement list        list zone's placement targets\n";
    cout << "  zone placement add         add a zone placement target\n";
    cout << "  zone placement modify      modify a zone placement target\n";
    cout << "  zone placement rm          remove a zone placement target\n";
    cout << "  pool add                   add an existing pool for data placement\n";
    cout << "  pool rm                    remove an existing pool from data placement set\n";
    cout << "  pools list                 list placement active set\n";
    cout << "  policy                     read bucket/object policy\n";
    cout << "  log list                   list log objects\n";
    cout << "  log show                   dump a log from specific object or (bucket + date\n";
    cout << "                             + bucket-id)\n";
    cout << "                             (NOTE: required to specify formatting of date\n";
    cout << "                             to \"YYYY-MM-DD-hh\")\n";
    cout << "  log rm                     remove log object\n";
    cout << "  usage show                 show usage (by user, date range)\n";
    cout << "  usage trim                 trim usage (by user, date range)\n";
    cout << "  gc list                    dump expired garbage collection objects (specify\n";
    cout << "                             --include-all to list all entries, including unexpired)\n";
    cout << "  gc process                 manually process garbage\n";
    cout << "  lc list                    list all bucket lifecycle progress\n";
    cout << "  lc process                 manually process lifecycle\n";
    cout << "  metadata get               get metadata info\n";
    cout << "  metadata put               put metadata info\n";
    cout << "  metadata rm                remove metadata info\n";
    cout << "  metadata list              list metadata info\n";
    cout << "  mdlog list                 list metadata log\n";
    cout << "  mdlog trim                 trim metadata log (use start-date, end-date or\n";
    cout << "                             start-marker, end-marker)\n";
    cout << "  mdlog status               read metadata log status\n";
    cout << "  bilog list                 list bucket index log\n";
    cout << "  bilog trim                 trim bucket index log (use start-marker, end-marker)\n";
    cout << "  datalog list               list data log\n";
    cout << "  datalog trim               trim data log\n";
    cout << "  datalog status             read data log status\n";
    cout << "  opstate list               list stateful operations entries (use client_id,\n";
    cout << "                             op_id, object)\n";
    cout << "  opstate set                set state on an entry (use client_id, op_id, object, state)\n";
    cout << "  opstate renew              renew state on an entry (use client_id, op_id, object)\n";
    cout << "  opstate rm                 remove entry (use client_id, op_id, object)\n";
    cout << "  replicalog get             get replica metadata log entry\n";
    cout << "  replicalog update          update replica metadata log entry\n";
    cout << "  replicalog delete          delete replica metadata log entry\n";
    cout << "  orphans find               init and run search for leaked rados objects (use job-id, pool)\n";
    cout << "  orphans finish             clean up search for leaked rados objects\n";
    cout << "  orphans list-jobs          list the current job-ids for orphans search\n";
    cout << "  role create                create a AWS role for use with STS\n";
    cout << "  role delete                delete a role\n";
    cout << "  role get                   get a role\n";
    cout << "  role list                  list roles with specified path prefix\n";
    cout << "  role modify                modify the assume role policy of an existing role\n";
    cout << "  role-policy put            add/update permission policy to role\n";
    cout << "  role-policy list           list policies attached to a role\n";
    cout << "  role-policy get            get the specified inline policy document embedded with the given role\n";
    cout << "  role-policy delete         delete policy attached to a role\n";
    cout << "  reshard add                schedule a resharding of a bucket\n";
    cout << "  reshard list               list all bucket resharding or scheduled to be reshared\n";
    cout << "  reshard process            process of scheduled reshard jobs\n";
    cout << "  reshard cancel             cancel resharding a bucket\n";
    cout << "options:\n";
    cout << "   --tenant=<tenant>         tenant name\n";
    cout << "   --uid=<id>                user id\n";
    cout << "   --subuser=<name>          subuser name\n";
    cout << "   --access-key=<key>        S3 access key\n";
    cout << "   --email=<email>\n";
    cout << "   --secret/--secret-key=<key>\n";
    cout << "                             specify secret key\n";
    cout << "   --gen-access-key          generate random access key (for S3)\n";
    cout << "   --gen-secret              generate random secret key\n";
    cout << "   --key-type=<type>         key type, options are: swift, s3\n";
    cout << "   --temp-url-key[-2]=<key>  temp url key\n";
    cout << "   --access=<access>         Set access permissions for sub-user, should be one\n";
    cout << "                             of read, write, readwrite, full\n";
    cout << "   --display-name=<name>\n";
    cout << "   --max-buckets             max number of buckets for a user\n";
    cout << "   --admin                   set the admin flag on the user\n";
    cout << "   --system                  set the system flag on the user\n";
    cout << "   --bucket=<bucket>\n";
    cout << "   --pool=<pool>\n";
    cout << "   --object=<object>\n";
    cout << "   --date=<date>\n";
    cout << "   --start-date=<date>\n";
    cout << "   --end-date=<date>\n";
    cout << "   --bucket-id=<bucket-id>\n";
    cout << "   --shard-id=<shard-id>     optional for mdlog list\n";
    cout << "                             required for: \n";
    cout << "                               mdlog trim\n";
    cout << "                               replica mdlog get/delete\n";
    cout << "                               replica datalog get/delete\n";
    cout << "   --metadata-key=<key>      key to retrieve metadata from with metadata get\n";
    cout << "   --remote=<remote>         zone or zonegroup id of remote gateway\n";
    cout << "   --period=<id>             period id\n";
    cout << "   --epoch=<number>          period epoch\n";
    cout << "   --commit                  commit the period during 'period update'\n";
    cout << "   --staging                 get staging period info\n";
    cout << "   --master                  set as master\n";
    cout << "   --master-url              master url\n";
    cout << "   --master-zonegroup=<id>   master zonegroup id\n";
    cout << "   --master-zone=<id>        master zone id\n";
    cout << "   --rgw-realm=<name>        realm name\n";
    cout << "   --realm-id=<id>           realm id\n";
    cout << "   --realm-new-name=<name>   realm new name\n";
    cout << "   --rgw-zonegroup=<name>    zonegroup name\n";
    cout << "   --zonegroup-id=<id>       zonegroup id\n";
    cout << "   --zonegroup-new-name=<name>\n";
    cout << "                             zonegroup new name\n";
    cout << "   --rgw-zone=<name>         name of zone in which radosgw is running\n";
    cout << "   --zone-id=<id>            zone id\n";
    cout << "   --zone-new-name=<name>    zone new name\n";
    cout << "   --source-zone             specify the source zone (for data sync)\n";
    cout << "   --default                 set entity (realm, zonegroup, zone) as default\n";
    cout << "   --read-only               set zone as read-only (when adding to zonegroup)\n";
    cout << "   --placement-id            placement id for zonegroup placement commands\n";
    cout << "   --tags=<list>             list of tags for zonegroup placement add and modify commands\n";
    cout << "   --tags-add=<list>         list of tags to add for zonegroup placement modify command\n";
    cout << "   --tags-rm=<list>          list of tags to remove for zonegroup placement modify command\n";
    cout << "   --endpoints=<list>        zone endpoints\n";
    cout << "   --index-pool=<pool>       placement target index pool\n";
    cout << "   --data-pool=<pool>        placement target data pool\n";
    cout << "   --data-extra-pool=<pool>  placement target data extra (non-ec) pool\n";
    cout << "   --placement-index-type=<type>\n";
    cout << "                             placement target index type (normal, indexless, or #id)\n";
    cout << "   --compression=<type>      placement target compression type (plugin name or empty/none)\n";
    cout << "   --tier-type=<type>        zone tier type\n";
    cout << "   --tier-config=<k>=<v>[,...]\n";
    cout << "                             set zone tier config keys, values\n";
    cout << "   --tier-config-rm=<k>[,...]\n";
    cout << "                             unset zone tier config keys\n";
    cout << "   --sync-from-all[=false]   set/reset whether zone syncs from all zonegroup peers\n";
    cout << "   --sync-from=[zone-name][,...]\n";
    cout << "                             set list of zones to sync from\n";
    cout << "   --sync-from-rm=[zone-name][,...]\n";
    cout << "                             remove zones from list of zones to sync from\n";
    cout << "   --fix                     besides checking bucket index, will also fix it\n";
    cout << "   --check-objects           bucket check: rebuilds bucket index according to\n";
    cout << "                             actual objects state\n";
    cout << "   --format=<format>         specify output format for certain operations: xml,\n";
    cout << "                             json\n";
    cout << "   --purge-data              when specified, user removal will also purge all the\n";
    cout << "                             user data\n";
    cout << "   --purge-keys              when specified, subuser removal will also purge all the\n";
    cout << "                             subuser keys\n";
    cout << "   --purge-objects           remove a bucket's objects before deleting it\n";
    cout << "                             (NOTE: required to delete a non-empty bucket)\n";
    cout << "   --sync-stats              option to 'user stats', update user stats with current\n";
    cout << "                             stats reported by user's buckets indexes\n";
    cout << "   --show-log-entries=<flag> enable/disable dump of log entries on log show\n";
    cout << "   --show-log-sum=<flag>     enable/disable dump of log summation on log show\n";
    cout << "   --skip-zero-entries       log show only dumps entries that don't have zero value\n";
    cout << "                             in one of the numeric field\n";
    cout << "   --infile=<file>           specify a file to read in when setting data\n";
    cout << "   --state=<state string>    specify a state for the opstate set command\n";
    cout << "   --replica-log-type        replica log type (metadata, data, bucket), required for\n";
    cout << "                             replica log operations\n";
    cout << "   --categories=<list>       comma separated list of categories, used in usage show\n";
    cout << "   --caps=<caps>             list of caps (e.g., \"usage=read, write; user=read\")\n";
    cout << "   --yes-i-really-mean-it    required for certain operations\n";
    cout << "   --warnings-only           when specified with bucket limit check, list\n";
    cout << "                             only buckets nearing or over the current max\n";
    cout << "                             objects per shard value\n";
    cout << "   --bypass-gc               when specified with bucket deletion, triggers\n";
    cout << "                             object deletions by not involving GC\n";
    cout << "   --inconsistent-index      when specified with bucket deletion and bypass-gc set to true,\n";
    cout << "                             ignores bucket index consistency\n";
    cout << "\n";
    cout << "<date> := \"YYYY-MM-DD[ hh:mm:ss]\"\n";
    cout << "\nQuota options:\n";
    cout << "   --bucket                  specified bucket for quota command\n";
    cout << "   --max-objects             specify max objects (negative value to disable)\n";
    cout << "   --max-size                specify max size (in B/K/M/G/T, negative value to disable)\n";
    cout << "   --quota-scope             scope of quota (bucket, user)\n";
    cout << "\nOrphans search options:\n";
    cout << "   --pool                    data pool to scan for leaked rados objects in\n";
    cout << "   --num-shards              num of shards to use for keeping the temporary scan info\n";
    cout << "   --orphan-stale-secs       num of seconds to wait before declaring an object to be an orphan (default: 86400)\n";
    cout << "   --job-id                  set the job id (for orphans find)\n";
    cout << "   --max-concurrent-ios      maximum concurrent ios for orphans find (default: 32)\n";
    cout << "\nOrphans list-jobs options:\n";
    cout << "   --extra-info              provide extra info in job list\n";
    cout << "\nRole options:\n";
    cout << "   --role-name               name of the role to create\n";
    cout << "   --path                    path to the role\n";
    cout << "   --assume-role-policy-doc  the trust relationship policy document that grants an entity permission to assume the role\n";
    cout << "   --policy-name             name of the policy document\n";
    cout << "   --policy-doc              permission policy document\n";
    cout << "   --path-prefix             path prefix for filtering roles\n";
    cout << "\n";
}